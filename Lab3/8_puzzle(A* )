import heapq

# The goal state
goal_state = [1, 2, 3,
              4, 5, 6,
              7, 8, 0]

# Moves possible (up, down, left, right)
moves = {
    'up': -3,
    'down': 3,
    'left': -1,
    'right': 1
}

# Heuristic: Manhattan distance
def manhattan(state):
    distance = 0
    for i, val in enumerate(state):
        if val != 0:
            goal_index = goal_state.index(val)
            x1, y1 = divmod(i, 3)
            x2, y2 = divmod(goal_index, 3)
            distance += abs(x1 - x2) + abs(y1 - y2)
    return distance

# Generate neighbors
def get_neighbors(state):
    neighbors = []
    blank = state.index(0)
    x, y = divmod(blank, 3)

    for move, pos_change in moves.items():
        new_blank = blank + pos_change
        # Valid moves: check grid boundaries
        if move == 'up' and x == 0: continue
        if move == 'down' and x == 2: continue
        if move == 'left' and y == 0: continue
        if move == 'right' and y == 2: continue

        new_state = state[:]
        new_state[blank], new_state[new_blank] = new_state[new_blank], new_state[blank]
        neighbors.append(new_state)

    return neighbors

# A* Algorithm
def astar(start_state):
    frontier = []
    heapq.heappush(frontier, (manhattan(start_state), 0, start_state, []))
    explored = set()

    while frontier:
        f, g, state, path = heapq.heappop(frontier)

        if state == goal_state:
            return path + [state]

        explored.add(tuple(state))

        for neighbor in get_neighbors(state):
            if tuple(neighbor) not in explored:
                new_g = g + 1
                new_f = new_g + manhattan(neighbor)
                heapq.heappush(frontier, (new_f, new_g, neighbor, path + [state]))

    return None

# Example
start = [1, 2, 3,
         4, 8, 0,
         7, 6, 5]

solution = astar(start)

print("Steps to solve:")
for step in solution:
    for i in range(0, 9, 3):
        print(step[i:i+3])
    print()
